//go:build fuzzoracle

package engine

// fuzz_test.go — Cross-language fuzz validation: Go engine vs Python oracle.
//
// Reads cfr/tests/fixtures/fuzz_traces.json (generated by
// cfr/tests/test_go_fuzz_oracle.py) and replays each game in the Go engine,
// asserting that at every decision point the Go engine matches the Python
// oracle for:
//   - acting_player
//   - decision_context
//   - legal_actions (sorted indices)
//   - hand_sizes
//   - discard_top_rank (card value, or null)
//   - stockpile_size
//   - is_terminal / utilities (on terminal entries)
//
// Run (after generating traces):
//
//	cd cfr && python tests/test_go_fuzz_oracle.py \
//	    --games 100 --output tests/fixtures/fuzz_traces.json
//	cd ../engine && go test -run TestFuzzOracle -v
//
// The trace file path is resolved via the FUZZ_TRACES env var, or defaults to
// ../cfr/tests/fixtures/fuzz_traces.json relative to this source file.

import (
	"encoding/json"
	"fmt"
	"math"
	"math/bits"
	"os"
	"path/filepath"
	"runtime"
	"slices"
	"testing"
)

// ---------------------------------------------------------------------------
// Trace types matching Python oracle JSON output
// ---------------------------------------------------------------------------

type FuzzEntry struct {
	Seed            int       `json:"seed"`
	TurnNumber      int       `json:"turn_number"`
	ActingPlayerPy  int       `json:"acting_player"`
	DecisionCtxPy   int       `json:"decision_context"`
	LegalActionsPy  []int     `json:"legal_actions"`
	ActionChosenIdx int       `json:"action_chosen_idx"`
	IsTerminal      bool      `json:"is_terminal"`
	Utilities       []float64 `json:"utilities"`
	HandSizesPy     []int     `json:"hand_sizes"`
	DiscardTopRank  *int      `json:"discard_top_rank"` // null → nil
	StockpileSize   int       `json:"stockpile_size"`
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

// traceFilePath returns the path to fuzz_traces.json.
// Checks FUZZ_TRACES env var first, then resolves relative to the source file.
func traceFilePath() string {
	if p := os.Getenv("FUZZ_TRACES"); p != "" {
		return p
	}
	// This file: engine/fuzz_test.go; repo root is one level up.
	_, thisFile, _, _ := runtime.Caller(0)
	repoRoot := filepath.Dir(filepath.Dir(thisFile))
	return filepath.Join(repoRoot, "cfr", "tests", "fixtures", "fuzz_traces.json")
}

// loadTraces reads and parses the fuzz trace JSON file.
// Skips the test (not fails) if the file is not yet generated.
func loadTraces(t *testing.T) []FuzzEntry {
	t.Helper()
	path := traceFilePath()
	data, err := os.ReadFile(path)
	if err != nil {
		t.Skipf("fuzz trace file not found (%s): run cfr/tests/test_go_fuzz_oracle.py first", path)
	}
	var entries []FuzzEntry
	if err := json.Unmarshal(data, &entries); err != nil {
		t.Fatalf("failed to parse fuzz traces: %v", err)
	}
	t.Logf("Loaded %d fuzz trace entries from %s", len(entries), path)
	return entries
}

// groupBySeed partitions entries into per-game slices, preserving order.
func groupBySeed(entries []FuzzEntry) map[int][]FuzzEntry {
	out := make(map[int][]FuzzEntry)
	for _, e := range entries {
		out[e.Seed] = append(out[e.Seed], e)
	}
	return out
}

// fuzzCTZ64 returns the number of trailing zero bits in v.
// (Named distinctly to avoid collision with integration_test.go's countTrailingZeros64
// when both build tags are active.)
func fuzzCTZ64(v uint64) int {
	return bits.TrailingZeros64(v)
}

// maskToSortedInts converts a [3]uint64 legal-action bitmask to a sorted []int.
func maskToSortedInts(mask [3]uint64) []int {
	var out []int
	for word := 0; word < 3; word++ {
		w := mask[word]
		for w != 0 {
			bit := w & (-w)
			w &^= bit
			idx := word*64 + fuzzCTZ64(bit)
			out = append(out, idx)
		}
	}
	slices.Sort(out)
	return out
}

// discardTopCardValue returns the integer value of the top discard card,
// or nil if the discard pile is empty.
func discardTopCardValue(gs GameState) *int {
	if gs.DiscardLen == 0 {
		return nil
	}
	c := gs.DiscardPile[gs.DiscardLen-1]
	v := int(c.Value())
	return &v
}

// floatClose returns true if a and b are within tol.
func floatClose(a, b float64, tol float64) bool {
	return math.Abs(a-b) <= tol
}

// ---------------------------------------------------------------------------
// TestFuzzOracle
// ---------------------------------------------------------------------------

// TestFuzzOracle replays every game from the Python oracle trace and asserts
// that the Go engine produces identical observable state at every decision point.
func TestFuzzOracle(t *testing.T) {
	entries := loadTraces(t)
	gameGroups := groupBySeed(entries)

	// Process seeds in sorted order for deterministic output.
	seeds := make([]int, 0, len(gameGroups))
	for s := range gameGroups {
		seeds = append(seeds, s)
	}
	slices.Sort(seeds)

	totalFailures := 0

	for _, seed := range seeds {
		gameEntries := gameGroups[seed]
		t.Run(fmt.Sprintf("seed%d", seed), func(t *testing.T) {
			hr := DefaultHouseRules()
			// Match Python oracle house rules exactly.
			hr.AllowDrawFromDiscard = false
			hr.AllowOpponentSnapping = false
			hr.MaxGameTurns = 300
			gs := NewGame(uint64(seed), hr)
			gs.Deal()

			// Python does NOT flip an initial card to the discard pile.
			// Go's Deal() does flip one card. We undo that flip here so that
			// both engines start with: discard=empty, stockpile unchanged.
			if gs.DiscardLen == 1 {
				// Move the initial discard card back to the top of the stockpile.
				gs.Stockpile[gs.StockLen] = gs.DiscardPile[0]
				gs.StockLen++
				gs.DiscardLen = 0
			}

			// Python's starting player is chosen with an unseeded RNG, so it
			// may differ from Go's seeded choice. Override Go's starting player
			// to match the first trace entry.
			if len(gameEntries) > 0 {
				gs.CurrentPlayer = uint8(gameEntries[0].ActingPlayerPy)
			}

			localFail := 0

			for step, entry := range gameEntries {
				// The Python trace entry records a mix of pre-action and post-action state:
				//   Pre-action:  acting_player, decision_context, legal_actions
				//   Post-action: hand_sizes, discard_top_rank, stockpile_size,
				//                is_terminal, utilities
				//
				// NOTE ON CARD INDEPENDENCE:
				//   Go and Python use different RNG algorithms, so the dealt cards differ.
				//   We therefore ONLY compare fields that do not depend on specific card ranks:
				//     - acting_player: pure turn-order
				//     - decision_context: pure state-machine phase
				//     - hand_sizes: structural (count only)
				//     - stockpile_size: structural (count only)
				//   We SKIP:
				//     - legal_actions at PostDraw/Snap: contain DiscardWithAbility
				//       and snap targets which depend on which card was drawn/discarded.
				//     - discard_top_rank: card-specific
				//     - utilities at terminal: depend on card values
				//
				//   We DO compare legal_actions at StartTurn (action 0/1/2 only depend on
				//   rules, not card ranks) and AbilitySelect (indices depend on hand length).
				//
				// We apply the chosen action index regardless of mismatches, since
				// the trace is replaying a valid Python game; the purpose is to verify
				// that Go does not crash and that structural state tracks correctly.

				// ---- Assert pre-action state ----

				ctx := DecisionContext(entry.DecisionCtxPy)

				// Acting player — always comparable (pure turn order).
				gotActor := int(gs.ActingPlayer())
				if gotActor != entry.ActingPlayerPy {
					t.Errorf("step %d: acting_player go=%d python=%d", step, gotActor, entry.ActingPlayerPy)
					localFail++
				}

				// Decision context — always comparable (pure state machine).
				gotCtx := int(gs.DecisionCtx())
				if gotCtx != entry.DecisionCtxPy {
					t.Errorf("step %d: decision_context go=%d python=%d", step, gotCtx, entry.DecisionCtxPy)
					localFail++
				}

				// Legal actions — only compare at contexts independent of card rank:
				//   CtxStartTurn (0): {DrawStockpile, DrawDiscard, CallCambia} — rule-based, not rank-based.
				//   CtxAbilitySelect (3): slot indices depend on hand lengths, not ranks.
				// Skip CtxPostDraw (1) and CtxSnapDecision (2) and CtxSnapMove (4) since
				// those include card-rank-dependent actions.
				if ctx == CtxStartTurn || ctx == CtxAbilitySelect {
					goLegal := maskToSortedInts(gs.LegalActions())
					pyLegal := make([]int, len(entry.LegalActionsPy))
					copy(pyLegal, entry.LegalActionsPy)
					slices.Sort(pyLegal)
					if !slices.Equal(goLegal, pyLegal) {
						t.Errorf("step %d: legal_actions mismatch (ctx=%d)\n  go:     %v\n  python: %v",
							step, ctx, goLegal, pyLegal)
						localFail++
					}
				}

				// Abort early on too many pre-action failures to avoid log spam.
				if localFail > 10 {
					t.Fatalf("too many failures in seed %d (step %d), aborting this game", seed, step)
				}

				// ---- Apply the chosen action ----
				chosenIdx := uint16(entry.ActionChosenIdx)
				if err := gs.ApplyAction(chosenIdx); err != nil {
					t.Fatalf("step %d: ApplyAction(%d) returned error: %v", step, chosenIdx, err)
				}

				// ---- Assert post-action state (card-independent fields only) ----

				// Hand sizes: purely structural.
				for p := 0; p < 2; p++ {
					goHand := int(gs.Players[p].HandLen)
					pyHand := entry.HandSizesPy[p]
					if goHand != pyHand {
						t.Errorf("step %d post: hand_sizes[%d] go=%d python=%d", step, p, goHand, pyHand)
						localFail++
					}
				}

				// Stockpile size: purely structural.
				goStock := int(gs.StockLen)
				if goStock != entry.StockpileSize {
					t.Errorf("step %d post: stockpile_size go=%d python=%d", step, goStock, entry.StockpileSize)
					localFail++
				}

				// discard_top_rank: card-specific — SKIP (different RNG, different cards).
				// utilities at terminal: card-specific — SKIP.

				// Abort early on too many post-action failures to avoid log spam.
				if localFail > 10 {
					t.Fatalf("too many failures in seed %d (step %d), aborting this game", seed, step)
				}

				// Verify terminal state is reached when Python says so.
				// (Don't check utilities since they depend on card values.)
				if entry.IsTerminal && !gs.IsTerminal() {
					t.Errorf("step %d post: expected terminal state, go engine is not terminal", step)
					localFail++
				}
			}
			totalFailures += localFail
		})

		if totalFailures > 100 {
			t.Fatalf("accumulated too many cross-language failures (%d), stopping", totalFailures)
		}
	}
}

// ---------------------------------------------------------------------------
// TestFuzzOracleTraceFormat: sanity-checks the trace file format.
// ---------------------------------------------------------------------------

func TestFuzzOracleTraceFormat(t *testing.T) {
	entries := loadTraces(t)
	if len(entries) == 0 {
		t.Fatal("trace file is empty")
	}

	for i, e := range entries {
		if e.Seed < 0 {
			t.Errorf("entry %d: negative seed %d", i, e.Seed)
		}
		if e.ActingPlayerPy < 0 || e.ActingPlayerPy > 1 {
			t.Errorf("entry %d: acting_player %d out of range", i, e.ActingPlayerPy)
		}
		if e.DecisionCtxPy < 0 || e.DecisionCtxPy > 5 {
			t.Errorf("entry %d: decision_context %d out of range", i, e.DecisionCtxPy)
		}
		for _, idx := range e.LegalActionsPy {
			if idx < 0 || idx >= 146 {
				t.Errorf("entry %d: legal action index %d out of range [0,146)", i, idx)
			}
		}
		if e.ActionChosenIdx < 0 || e.ActionChosenIdx >= 146 {
			t.Errorf("entry %d: action_chosen_idx %d out of range", i, e.ActionChosenIdx)
		}
		if len(e.HandSizesPy) != 2 {
			t.Errorf("entry %d: hand_sizes length %d, want 2", i, len(e.HandSizesPy))
		}
		if e.StockpileSize < 0 {
			t.Errorf("entry %d: negative stockpile_size %d", i, e.StockpileSize)
		}
		if len(e.Utilities) != 2 {
			t.Errorf("entry %d: utilities length %d, want 2", i, len(e.Utilities))
		}
	}
}
